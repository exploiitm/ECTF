import argparse
import struct
import json
from Crypto.Cipher import AES
import hmac
import hashlib
from typing import Annotated

Bytes64 = Annotated[bytes, 64]
Bytes32 = Annotated[bytes, 32]
Bytes4 = Annotated[bytes, 4]

def aeshash(input: Bytes32, key: Bytes32) -> Bytes32:
    cipher = AES.new(key, AES.MODE_ECB)
    encrypted = cipher.encrypt(input)
    return bytes(a ^ b for a, b in zip(encrypted, input))

# econder config
DEPTH = 64
# HASH_FUNC = aeshash
HASH_FUNC = lambda x, key : hmac.new(key, x, hashlib.sha256).digest()

def pad_to_64_bytes(data: bytes) -> Bytes64:
    return data.ljust(64, b'\x00')[:64]  # Pad with null bytes and truncate if longer

# Segment key derivation
def derive_right(parent_key: Bytes32) -> Bytes32:
    right_key = struct.pack(">8I", *([0xDEADBEEF] * 8))
    return HASH_FUNC(parent_key, right_key)

def derive_left(parent_key: Bytes32) -> Bytes32:
    left_key = struct.pack(">8I", *([0xC0D3D00D] * 8))
    return HASH_FUNC(parent_key, left_key)

def get_key(master_key: Bytes32, timestamp: int):
    if (timestamp >= 1 << DEPTH) or (timestamp < 0):
        raise ValueError("The timestamp is not b/w 0 - 2^64")

    key = master_key
    for c in format(timestamp, '064b'):
        if c == '0':
            key = derive_left(key)
        else:
            key = derive_right(key)

    return key

# Encoder class
class Encoder:
    global_secrets: dict

    def __init__(self, secrets: bytes):
        """
        Function to initialise the encoder and parse secerts

        :param secrets: Contents of the secrets file generated by
            ectf25_design.gen_secrets
        """
        # Load the json of the secrets file
        self.global_secrets = json.loads(secrets.decode("utf-8"))

    def encode(self, channel: int, frame: bytes, timestamp: int) -> bytes:
        """
        This will be called for every frame that needs to be encoded before being
        transmitted by the satellite to all listening TVs

        :param channel: 16b unsigned channel number. Channel 0 is the emergency
            broadcast that must be decodable by all channels.
        :param frame: Frame to encode. Max frame size is 64 bytes.
        :param timestamp: 64b timestamp to use for encoding. **NOTE**: This value may
            have no relation to the current timestamp, so you should not compare it
            against the current time. The timestamp is guaranteed to strictly
            monotonically increase (always go up) with subsequent calls to encode

        :returns: The encoded frame, which will be sent to the Decoder
        """
        if str(channel) not in self.global_secrets:
            raise ValueError("Invalid channel: No secret key found for the given channel")

        # Retrieve the master secret for the given channel
        Ks = bytes.fromhex(self.global_secrets[str(channel)])

        # Retrieve key for current timestamp
        timestamp_key = get_key(Ks, timestamp)

        # Encoding the frame
        cipher = AES.new(timestamp_key, AES.MODE_ECB)
        encrypted_frame = cipher.encrypt(pad_to_64_bytes(frame))        

        # Builinding base packet
        packet_header = (
            timestamp.to_bytes(8, 'big') + 
            channel.to_bytes(4, 'big') +
            len(frame).to_bytes(1, 'big')
        )
        packet_unsigned = packet_header + encrypted_frame

        # Generate HMAC signature using same timestamp key
        signature = hmac.new(timestamp_key, packet_unsigned, hashlib.sha256).digest()

        return (
            packet_unsigned + 
            signature
        )


def main():
    """A test main to one-shot encode a frame

    This function is only for your convenience and will not be used in the final design.

    After pip-installing, you should be able to call this with:
        python3 -m ectf25_design.encoder path/to/test.secrets 1 "frame to encode" 100
    """
    parser = argparse.ArgumentParser(prog="ectf25_design.encoder")
    parser.add_argument(
        "secrets_file", type=argparse.FileType("rb"), help="Path to the secrets file"
    )

    parser.add_argument("channel", type=int, help="Channel to encode for")
    parser.add_argument("frame", help="Contents of the frame")
    parser.add_argument("timestamp", type=int, help="64b timestamp to use")
    args = parser.parse_args()

    encoder = Encoder(args.secrets_file.read())
    packet = repr(encoder.encode(args.channel, args.frame.encode(), args.timestamp))
    print(repr(packet))
    print(len(packet))


if __name__ == "__main__":
    main()

